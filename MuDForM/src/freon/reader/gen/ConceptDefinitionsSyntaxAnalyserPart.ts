// Generated by the Freon Language Generator.
import { net } from "net.akehurst.language-agl-processor";
import SPPTBranch = net.akehurst.language.api.sppt.SPPTBranch;
import {
    ConceptDefinitions,
    SimpleValueDef,
    EntityDef,
    ValueAttribute,
    ReferenceAttribute,
    TransitionDef,
    DbType,
    ValueDef,
} from "../../language/gen/index.js";
import { MuDForM_ModelSyntaxAnalyser } from "./MuDForM_ModelSyntaxAnalyser.js";
import { FreNodeReference } from "@freon4dsl/core";

export class ConceptDefinitionsSyntaxAnalyserPart {
    mainAnalyser: MuDForM_ModelSyntaxAnalyser;

    constructor(mainAnalyser: MuDForM_ModelSyntaxAnalyser) {
        this.mainAnalyser = mainAnalyser;
    }

    /**
     * Method to transform branches that match the following rule:
     * ConceptDefinitions = 'ConceptDefinitions' identifier '\{'
     *	 'simple_values'
     *	 SimpleValueDef*
     *	 'entities'
     *	 EntityDef*
     *	 'transitions'
     *	 TransitionDef*
     *	 '}' ;
     * @param branch
     * @private
     */
    public transformConceptDefinitions(branch: SPPTBranch): ConceptDefinitions {
        // console.log('transformConceptDefinitions called: ' + branch.name);
        let __name: string;
        let __simple_values: SimpleValueDef[];
        let __entities: EntityDef[];
        let __transitions: TransitionDef[];
        const children = this.mainAnalyser.getChildren(branch);
        __name = this.mainAnalyser.transformSharedPackedParseTreeNode(children[1]); // RHSPrimEntry
        // RHSPartListEntry
        if (children[4].name !== "SimpleValueDef") {
            __simple_values = this.mainAnalyser.transformSharedPackedParseTreeList<SimpleValueDef>(children[4]);
        } else {
            // special case: only when this entry is the single rhs entry of this rule
            __simple_values = [];
            for (const child of children) {
                __simple_values.push(this.mainAnalyser.transformSharedPackedParseTreeNode(child));
            }
        } // RHSPartListEntry
        if (children[6].name !== "EntityDef") {
            __entities = this.mainAnalyser.transformSharedPackedParseTreeList<EntityDef>(children[6]);
        } else {
            // special case: only when this entry is the single rhs entry of this rule
            __entities = [];
            for (const child of children) {
                __entities.push(this.mainAnalyser.transformSharedPackedParseTreeNode(child));
            }
        } // RHSPartListEntry
        if (children[8].name !== "TransitionDef") {
            __transitions = this.mainAnalyser.transformSharedPackedParseTreeList<TransitionDef>(children[8]);
        } else {
            // special case: only when this entry is the single rhs entry of this rule
            __transitions = [];
            for (const child of children) {
                __transitions.push(this.mainAnalyser.transformSharedPackedParseTreeNode(child));
            }
        }
        return ConceptDefinitions.create({
            name: __name,
            simple_values: __simple_values,
            entities: __entities,
            transitions: __transitions,
            parseLocation: this.mainAnalyser.location(branch),
        });
    }

    /**
     * Method to transform branches that match the following rule:
     * SimpleValueDef = 'SimpleValueDef' identifier '\{'
     *	 'doc' stringLiteral
     *	 'db_type' DbType
     *	 '}' ;
     * @param branch
     * @private
     */
    public transformSimpleValueDef(branch: SPPTBranch): SimpleValueDef {
        // console.log('transformSimpleValueDef called: ' + branch.name);
        let __name: string;
        let __doc: string;
        let __db_type: FreNodeReference<DbType>;
        const children = this.mainAnalyser.getChildren(branch);
        __name = this.mainAnalyser.transformSharedPackedParseTreeNode(children[1]); // RHSPrimEntry
        __doc = this.mainAnalyser.transformSharedPackedParseTreeNode(children[4]); // RHSPrimEntry
        __db_type = this.mainAnalyser.freNodeRef<DbType>(children[6], "DbType"); // RHSLimitedRefEntry

        return SimpleValueDef.create({
            name: __name,
            doc: __doc,
            db_type: __db_type,
            parseLocation: this.mainAnalyser.location(branch),
        });
    }

    /**
     * Method to transform branches that match the following rule:
     * EntityDef = 'EntityDef' identifier '\{'
     *	 'doc' stringLiteral
     *	 'properties'
     *	 ValueAttribute*
     *	 'relations'
     *	 ReferenceAttribute*
     *	 '}' ;
     * @param branch
     * @private
     */
    public transformEntityDef(branch: SPPTBranch): EntityDef {
        // console.log('transformEntityDef called: ' + branch.name);
        let __name: string;
        let __doc: string;
        let __properties: ValueAttribute[];
        let __relations: ReferenceAttribute[];
        const children = this.mainAnalyser.getChildren(branch);
        __name = this.mainAnalyser.transformSharedPackedParseTreeNode(children[1]); // RHSPrimEntry
        __doc = this.mainAnalyser.transformSharedPackedParseTreeNode(children[4]); // RHSPrimEntry
        // RHSPartListEntry
        if (children[6].name !== "ValueAttribute") {
            __properties = this.mainAnalyser.transformSharedPackedParseTreeList<ValueAttribute>(children[6]);
        } else {
            // special case: only when this entry is the single rhs entry of this rule
            __properties = [];
            for (const child of children) {
                __properties.push(this.mainAnalyser.transformSharedPackedParseTreeNode(child));
            }
        } // RHSPartListEntry
        if (children[8].name !== "ReferenceAttribute") {
            __relations = this.mainAnalyser.transformSharedPackedParseTreeList<ReferenceAttribute>(children[8]);
        } else {
            // special case: only when this entry is the single rhs entry of this rule
            __relations = [];
            for (const child of children) {
                __relations.push(this.mainAnalyser.transformSharedPackedParseTreeNode(child));
            }
        }
        return EntityDef.create({
            name: __name,
            doc: __doc,
            properties: __properties,
            relations: __relations,
            parseLocation: this.mainAnalyser.location(branch),
        });
    }

    /**
     * Method to transform branches that match the following rule:
     * ValueAttribute = 'ValueAttribute' identifier '\{'
     *	 'valueRef' __fre_reference
     *	 '}' ;
     * @param branch
     * @private
     */
    public transformValueAttribute(branch: SPPTBranch): ValueAttribute {
        // console.log('transformValueAttribute called: ' + branch.name);
        let __name: string;
        let __valueRef: FreNodeReference<ValueDef>;
        const children = this.mainAnalyser.getChildren(branch);
        __name = this.mainAnalyser.transformSharedPackedParseTreeNode(children[1]); // RHSPrimEntry
        __valueRef = this.mainAnalyser.freNodeRef<ValueDef>(children[4], "ValueDef"); // RHSRefEntry

        return ValueAttribute.create({
            name: __name,
            valueRef: __valueRef,
            parseLocation: this.mainAnalyser.location(branch),
        });
    }

    /**
     * Method to transform branches that match the following rule:
     * ReferenceAttribute = 'ReferenceAttribute' identifier '\{'
     *	 'entityRef' __fre_reference
     *	 '}' ;
     * @param branch
     * @private
     */
    public transformReferenceAttribute(branch: SPPTBranch): ReferenceAttribute {
        // console.log('transformReferenceAttribute called: ' + branch.name);
        let __name: string;
        let __entityRef: FreNodeReference<EntityDef>;
        const children = this.mainAnalyser.getChildren(branch);
        __name = this.mainAnalyser.transformSharedPackedParseTreeNode(children[1]); // RHSPrimEntry
        __entityRef = this.mainAnalyser.freNodeRef<EntityDef>(children[4], "EntityDef"); // RHSRefEntry

        return ReferenceAttribute.create({
            name: __name,
            entityRef: __entityRef,
            parseLocation: this.mainAnalyser.location(branch),
        });
    }

    /**
     * Method to transform branches that match the following rule:
     * TransitionDef = 'TransitionDef' identifier '\{'
     *	 'doc' stringLiteral
     *	 'parameters'
     *	 ValueAttribute*
     *	 'involvements'
     *	 ReferenceAttribute*
     *	 '}' ;
     * @param branch
     * @private
     */
    public transformTransitionDef(branch: SPPTBranch): TransitionDef {
        // console.log('transformTransitionDef called: ' + branch.name);
        let __name: string;
        let __doc: string;
        let __parameters: ValueAttribute[];
        let __involvements: ReferenceAttribute[];
        const children = this.mainAnalyser.getChildren(branch);
        __name = this.mainAnalyser.transformSharedPackedParseTreeNode(children[1]); // RHSPrimEntry
        __doc = this.mainAnalyser.transformSharedPackedParseTreeNode(children[4]); // RHSPrimEntry
        // RHSPartListEntry
        if (children[6].name !== "ValueAttribute") {
            __parameters = this.mainAnalyser.transformSharedPackedParseTreeList<ValueAttribute>(children[6]);
        } else {
            // special case: only when this entry is the single rhs entry of this rule
            __parameters = [];
            for (const child of children) {
                __parameters.push(this.mainAnalyser.transformSharedPackedParseTreeNode(child));
            }
        } // RHSPartListEntry
        if (children[8].name !== "ReferenceAttribute") {
            __involvements = this.mainAnalyser.transformSharedPackedParseTreeList<ReferenceAttribute>(children[8]);
        } else {
            // special case: only when this entry is the single rhs entry of this rule
            __involvements = [];
            for (const child of children) {
                __involvements.push(this.mainAnalyser.transformSharedPackedParseTreeNode(child));
            }
        }
        return TransitionDef.create({
            name: __name,
            doc: __doc,
            parameters: __parameters,
            involvements: __involvements,
            parseLocation: this.mainAnalyser.location(branch),
        });
    }

    /**
     * Method to transform branches that match the following rule:
     * DbType = 'bigdec'
     *	| 'bigint'
     *	| 'boolean'
     *	| 'bytes'
     *	| 'double'
     *	| 'float'
     *	| 'instant'
     *	| 'keyword'
     *	| 'long'
     *	| 'string'
     *	| 'symbol'
     *	| 'uuid'
     *	| 'uri' ;
     * @param branch
     * @private
     */
    public transformDbType(branch: SPPTBranch): DbType {
        const choice = branch.nonSkipMatchedText;
        if (choice === "bigdec") {
            return DbType.bigdec;
        } else if (choice === "bigint") {
            return DbType.bigint;
        } else if (choice === "boolean") {
            return DbType.boolean;
        } else if (choice === "bytes") {
            return DbType.bytes;
        } else if (choice === "double") {
            return DbType.double;
        } else if (choice === "float") {
            return DbType.float;
        } else if (choice === "instant") {
            return DbType.instant;
        } else if (choice === "keyword") {
            return DbType.keyword;
        } else if (choice === "long") {
            return DbType.long;
        } else if (choice === "string") {
            return DbType.string;
        } else if (choice === "symbol") {
            return DbType.symbol;
        } else if (choice === "uuid") {
            return DbType.uuid;
        } else if (choice === "uri") {
            return DbType.uri;
        } else {
            return null;
        }
    }
}
