// Generated by the Freon Language Generator.
import { net } from "net.akehurst.language-agl-processor";
import SPPTBranch = net.akehurst.language.api.sppt.SPPTBranch;
import {
    ConceptTypeDefinitions,
    ValueTypeDef,
    SimpleValueType,
    ProductValueType,
    TypeField,
    SumValueType,
    ListValueType,
    ValueTypeReference,
    EntityTypeDef,
    ValueAttribute,
    ReferenceAttribute,
    TransitionTypeDef,
    ValueType,
    DatomicType,
} from "../../language/gen/index.js";
import { MuDForM_ModelSyntaxAnalyser } from "./MuDForM_ModelSyntaxAnalyser.js";
import { FreNodeReference } from "@freon4dsl/core";

export class ConceptTypeDefinitionsSyntaxAnalyserPart {
    mainAnalyser: MuDForM_ModelSyntaxAnalyser;

    constructor(mainAnalyser: MuDForM_ModelSyntaxAnalyser) {
        this.mainAnalyser = mainAnalyser;
    }

    /**
     * Method to transform branches that match the following rule:
     * ConceptTypeDefinitions = 'ConceptTypeDefinitions' identifier '\{'
     *	 'doc' stringLiteral
     *	 'values'
     *	 ValueTypeDef*
     *	 'entities'
     *	 EntityTypeDef*
     *	 'transitions'
     *	 TransitionTypeDef*
     *	 '}' ;
     * @param branch
     * @private
     */
    public transformConceptTypeDefinitions(branch: SPPTBranch): ConceptTypeDefinitions {
        // console.log('transformConceptTypeDefinitions called: ' + branch.name);
        let __name: string;
        let __doc: string;
        let __values: ValueTypeDef[];
        let __entities: EntityTypeDef[];
        let __transitions: TransitionTypeDef[];
        const children = this.mainAnalyser.getChildren(branch);
        __name = this.mainAnalyser.transformSharedPackedParseTreeNode(children[1]); // RHSPrimEntry
        __doc = this.mainAnalyser.transformSharedPackedParseTreeNode(children[4]); // RHSPrimEntry
        // RHSPartListEntry
        if (children[6].name !== "ValueTypeDef") {
            __values = this.mainAnalyser.transformSharedPackedParseTreeList<ValueTypeDef>(children[6]);
        } else {
            // special case: only when this entry is the single rhs entry of this rule
            __values = [];
            for (const child of children) {
                __values.push(this.mainAnalyser.transformSharedPackedParseTreeNode(child));
            }
        } // RHSPartListEntry
        if (children[8].name !== "EntityTypeDef") {
            __entities = this.mainAnalyser.transformSharedPackedParseTreeList<EntityTypeDef>(children[8]);
        } else {
            // special case: only when this entry is the single rhs entry of this rule
            __entities = [];
            for (const child of children) {
                __entities.push(this.mainAnalyser.transformSharedPackedParseTreeNode(child));
            }
        } // RHSPartListEntry
        if (children[10].name !== "TransitionTypeDef") {
            __transitions = this.mainAnalyser.transformSharedPackedParseTreeList<TransitionTypeDef>(children[10]);
        } else {
            // special case: only when this entry is the single rhs entry of this rule
            __transitions = [];
            for (const child of children) {
                __transitions.push(this.mainAnalyser.transformSharedPackedParseTreeNode(child));
            }
        }
        return ConceptTypeDefinitions.create({
            name: __name,
            doc: __doc,
            values: __values,
            entities: __entities,
            transitions: __transitions,
            parseLocation: this.mainAnalyser.location(branch),
        });
    }

    /**
     * Method to transform branches that match the following rule:
     * ValueTypeDef = 'ValueTypeDef' identifier '\{'
     *	 'doc' stringLiteral
     *	 'type' ValueType
     *	 '}' ;
     * @param branch
     * @private
     */
    public transformValueTypeDef(branch: SPPTBranch): ValueTypeDef {
        // console.log('transformValueTypeDef called: ' + branch.name);
        let __name: string;
        let __doc: string;
        let __type: ValueType;
        const children = this.mainAnalyser.getChildren(branch);
        __name = this.mainAnalyser.transformSharedPackedParseTreeNode(children[1]); // RHSPrimEntry
        __doc = this.mainAnalyser.transformSharedPackedParseTreeNode(children[4]); // RHSPrimEntry
        __type = this.mainAnalyser.transformSharedPackedParseTreeNode(children[6]); // RHSPartEntry

        return ValueTypeDef.create({
            name: __name,
            doc: __doc,
            type: __type,
            parseLocation: this.mainAnalyser.location(branch),
        });
    }

    /**
     * Method to transform branches that match the following rule:
     * SimpleValueType = 'SimpleValueType' '\{'
     *	 'primitive_type' DatomicType
     *	 '}' ;
     * @param branch
     * @private
     */
    public transformSimpleValueType(branch: SPPTBranch): SimpleValueType {
        // console.log('transformSimpleValueType called: ' + branch.name);
        let __primitive_type: FreNodeReference<DatomicType>;
        const children = this.mainAnalyser.getChildren(branch);
        __primitive_type = this.mainAnalyser.freNodeRef<DatomicType>(children[3], "DatomicType"); // RHSLimitedRefEntry

        return SimpleValueType.create({
            primitive_type: __primitive_type,
            parseLocation: this.mainAnalyser.location(branch),
        });
    }

    /**
     * Method to transform branches that match the following rule:
     * ProductValueType = 'ProductValueType' '\{'
     *	 'fields'
     *	 TypeField*
     *	 '}' ;
     * @param branch
     * @private
     */
    public transformProductValueType(branch: SPPTBranch): ProductValueType {
        // console.log('transformProductValueType called: ' + branch.name);
        let __fields: TypeField[];
        const children = this.mainAnalyser.getChildren(branch); // RHSPartListEntry
        if (children[3].name !== "TypeField") {
            __fields = this.mainAnalyser.transformSharedPackedParseTreeList<TypeField>(children[3]);
        } else {
            // special case: only when this entry is the single rhs entry of this rule
            __fields = [];
            for (const child of children) {
                __fields.push(this.mainAnalyser.transformSharedPackedParseTreeNode(child));
            }
        }
        return ProductValueType.create({
            fields: __fields,
            parseLocation: this.mainAnalyser.location(branch),
        });
    }

    /**
     * Method to transform branches that match the following rule:
     * TypeField = 'TypeField' '\{'
     *	 'label' stringLiteral
     *	 'type' ValueType
     *	 '}' ;
     * @param branch
     * @private
     */
    public transformTypeField(branch: SPPTBranch): TypeField {
        // console.log('transformTypeField called: ' + branch.name);
        let __label: string;
        let __type: ValueType;
        const children = this.mainAnalyser.getChildren(branch);
        __label = this.mainAnalyser.transformSharedPackedParseTreeNode(children[3]); // RHSPrimEntry
        __type = this.mainAnalyser.transformSharedPackedParseTreeNode(children[5]); // RHSPartEntry

        return TypeField.create({
            label: __label,
            type: __type,
            parseLocation: this.mainAnalyser.location(branch),
        });
    }

    /**
     * Method to transform branches that match the following rule:
     * SumValueType = 'SumValueType' '\{'
     *	 'fields'
     *	 TypeField*
     *	 '}' ;
     * @param branch
     * @private
     */
    public transformSumValueType(branch: SPPTBranch): SumValueType {
        // console.log('transformSumValueType called: ' + branch.name);
        let __fields: TypeField[];
        const children = this.mainAnalyser.getChildren(branch); // RHSPartListEntry
        if (children[3].name !== "TypeField") {
            __fields = this.mainAnalyser.transformSharedPackedParseTreeList<TypeField>(children[3]);
        } else {
            // special case: only when this entry is the single rhs entry of this rule
            __fields = [];
            for (const child of children) {
                __fields.push(this.mainAnalyser.transformSharedPackedParseTreeNode(child));
            }
        }
        return SumValueType.create({
            fields: __fields,
            parseLocation: this.mainAnalyser.location(branch),
        });
    }

    /**
     * Method to transform branches that match the following rule:
     * ListValueType = 'ListValueType' '\{'
     *	 'list' ValueType
     *	 '}' ;
     * @param branch
     * @private
     */
    public transformListValueType(branch: SPPTBranch): ListValueType {
        // console.log('transformListValueType called: ' + branch.name);
        let __list: ValueType;
        const children = this.mainAnalyser.getChildren(branch);
        __list = this.mainAnalyser.transformSharedPackedParseTreeNode(children[3]); // RHSPartEntry

        return ListValueType.create({
            list: __list,
            parseLocation: this.mainAnalyser.location(branch),
        });
    }

    /**
     * Method to transform branches that match the following rule:
     * ValueTypeReference = 'ValueTypeReference' '\{'
     *	 'defRef' __fre_reference
     *	 '}' ;
     * @param branch
     * @private
     */
    public transformValueTypeReference(branch: SPPTBranch): ValueTypeReference {
        // console.log('transformValueTypeReference called: ' + branch.name);
        let __defRef: FreNodeReference<ValueTypeDef>;
        const children = this.mainAnalyser.getChildren(branch);
        __defRef = this.mainAnalyser.freNodeRef<ValueTypeDef>(children[3], "ValueTypeDef"); // RHSRefEntry

        return ValueTypeReference.create({
            defRef: __defRef,
            parseLocation: this.mainAnalyser.location(branch),
        });
    }

    /**
     * Method to transform branches that match the following rule:
     * EntityTypeDef = 'EntityTypeDef' identifier '\{'
     *	 'doc' stringLiteral
     *	 'properties'
     *	 ValueAttribute*
     *	 'relations'
     *	 ReferenceAttribute*
     *	 '}' ;
     * @param branch
     * @private
     */
    public transformEntityTypeDef(branch: SPPTBranch): EntityTypeDef {
        // console.log('transformEntityTypeDef called: ' + branch.name);
        let __name: string;
        let __doc: string;
        let __properties: ValueAttribute[];
        let __relations: ReferenceAttribute[];
        const children = this.mainAnalyser.getChildren(branch);
        __name = this.mainAnalyser.transformSharedPackedParseTreeNode(children[1]); // RHSPrimEntry
        __doc = this.mainAnalyser.transformSharedPackedParseTreeNode(children[4]); // RHSPrimEntry
        // RHSPartListEntry
        if (children[6].name !== "ValueAttribute") {
            __properties = this.mainAnalyser.transformSharedPackedParseTreeList<ValueAttribute>(children[6]);
        } else {
            // special case: only when this entry is the single rhs entry of this rule
            __properties = [];
            for (const child of children) {
                __properties.push(this.mainAnalyser.transformSharedPackedParseTreeNode(child));
            }
        } // RHSPartListEntry
        if (children[8].name !== "ReferenceAttribute") {
            __relations = this.mainAnalyser.transformSharedPackedParseTreeList<ReferenceAttribute>(children[8]);
        } else {
            // special case: only when this entry is the single rhs entry of this rule
            __relations = [];
            for (const child of children) {
                __relations.push(this.mainAnalyser.transformSharedPackedParseTreeNode(child));
            }
        }
        return EntityTypeDef.create({
            name: __name,
            doc: __doc,
            properties: __properties,
            relations: __relations,
            parseLocation: this.mainAnalyser.location(branch),
        });
    }

    /**
     * Method to transform branches that match the following rule:
     * ValueAttribute = 'ValueAttribute' '\{'
     *	 'label' stringLiteral
     *	 'valueRef' __fre_reference
     *	 '}' ;
     * @param branch
     * @private
     */
    public transformValueAttribute(branch: SPPTBranch): ValueAttribute {
        // console.log('transformValueAttribute called: ' + branch.name);
        let __label: string;
        let __valueRef: FreNodeReference<ValueTypeDef>;
        const children = this.mainAnalyser.getChildren(branch);
        __label = this.mainAnalyser.transformSharedPackedParseTreeNode(children[3]); // RHSPrimEntry
        __valueRef = this.mainAnalyser.freNodeRef<ValueTypeDef>(children[5], "ValueTypeDef"); // RHSRefEntry

        return ValueAttribute.create({
            label: __label,
            valueRef: __valueRef,
            parseLocation: this.mainAnalyser.location(branch),
        });
    }

    /**
     * Method to transform branches that match the following rule:
     * ReferenceAttribute = 'ReferenceAttribute' '\{'
     *	 'label' stringLiteral
     *	 'entityRef' __fre_reference
     *	 '}' ;
     * @param branch
     * @private
     */
    public transformReferenceAttribute(branch: SPPTBranch): ReferenceAttribute {
        // console.log('transformReferenceAttribute called: ' + branch.name);
        let __label: string;
        let __entityRef: FreNodeReference<EntityTypeDef>;
        const children = this.mainAnalyser.getChildren(branch);
        __label = this.mainAnalyser.transformSharedPackedParseTreeNode(children[3]); // RHSPrimEntry
        __entityRef = this.mainAnalyser.freNodeRef<EntityTypeDef>(children[5], "EntityTypeDef"); // RHSRefEntry

        return ReferenceAttribute.create({
            label: __label,
            entityRef: __entityRef,
            parseLocation: this.mainAnalyser.location(branch),
        });
    }

    /**
     * Method to transform branches that match the following rule:
     * TransitionTypeDef = 'TransitionTypeDef' identifier '\{'
     *	 'doc' stringLiteral
     *	 'parameters'
     *	 ValueAttribute*
     *	 'involvements'
     *	 ReferenceAttribute*
     *	 '}' ;
     * @param branch
     * @private
     */
    public transformTransitionTypeDef(branch: SPPTBranch): TransitionTypeDef {
        // console.log('transformTransitionTypeDef called: ' + branch.name);
        let __name: string;
        let __doc: string;
        let __parameters: ValueAttribute[];
        let __involvements: ReferenceAttribute[];
        const children = this.mainAnalyser.getChildren(branch);
        __name = this.mainAnalyser.transformSharedPackedParseTreeNode(children[1]); // RHSPrimEntry
        __doc = this.mainAnalyser.transformSharedPackedParseTreeNode(children[4]); // RHSPrimEntry
        // RHSPartListEntry
        if (children[6].name !== "ValueAttribute") {
            __parameters = this.mainAnalyser.transformSharedPackedParseTreeList<ValueAttribute>(children[6]);
        } else {
            // special case: only when this entry is the single rhs entry of this rule
            __parameters = [];
            for (const child of children) {
                __parameters.push(this.mainAnalyser.transformSharedPackedParseTreeNode(child));
            }
        } // RHSPartListEntry
        if (children[8].name !== "ReferenceAttribute") {
            __involvements = this.mainAnalyser.transformSharedPackedParseTreeList<ReferenceAttribute>(children[8]);
        } else {
            // special case: only when this entry is the single rhs entry of this rule
            __involvements = [];
            for (const child of children) {
                __involvements.push(this.mainAnalyser.transformSharedPackedParseTreeNode(child));
            }
        }
        return TransitionTypeDef.create({
            name: __name,
            doc: __doc,
            parameters: __parameters,
            involvements: __involvements,
            parseLocation: this.mainAnalyser.location(branch),
        });
    }

    /**
     * Method to transform branches that match the following rule:
     * ValueType = SimpleValueType
     *    | ProductValueType
     *    | SumValueType
     *    | ListValueType
     *    | ValueTypeReference  ;
     * @param branch
     * @private
     */
    public transformValueType(branch: SPPTBranch): ValueType {
        // console.log('transformValueType called: ' + branch.name);
        return this.mainAnalyser.transformSharedPackedParseTreeNode(branch.nonSkipChildren.toArray()[0]);
    }

    /**
     * Method to transform branches that match the following rule:
     * DatomicType = 'bigdec'
     *	| 'bigint'
     *	| 'boolean'
     *	| 'bytes'
     *	| 'double'
     *	| 'float'
     *	| 'instant'
     *	| 'keyword'
     *	| 'long'
     *	| 'string'
     *	| 'symbol'
     *	| 'uuid'
     *	| 'uri' ;
     * @param branch
     * @private
     */
    public transformDatomicType(branch: SPPTBranch): DatomicType {
        const choice = branch.nonSkipMatchedText;
        if (choice === "bigdec") {
            return DatomicType.bigdec;
        } else if (choice === "bigint") {
            return DatomicType.bigint;
        } else if (choice === "boolean") {
            return DatomicType.boolean;
        } else if (choice === "bytes") {
            return DatomicType.bytes;
        } else if (choice === "double") {
            return DatomicType.double;
        } else if (choice === "float") {
            return DatomicType.float;
        } else if (choice === "instant") {
            return DatomicType.instant;
        } else if (choice === "keyword") {
            return DatomicType.keyword;
        } else if (choice === "long") {
            return DatomicType.long;
        } else if (choice === "string") {
            return DatomicType.string;
        } else if (choice === "symbol") {
            return DatomicType.symbol;
        } else if (choice === "uuid") {
            return DatomicType.uuid;
        } else if (choice === "uri") {
            return DatomicType.uri;
        } else {
            return null;
        }
    }
}
