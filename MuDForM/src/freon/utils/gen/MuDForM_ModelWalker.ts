// Generated by the Freon Language Generator.
// import { FreNode } from "../../language/gen/index.js";
import {
    SimpleValueDef,
    DbType,
    ReferenceAttribute,
    ValueAttribute,
    TransitionDef,
    EntityDef,
    ValueDef,
    ConceptDefinitions,
    MuDForM_Model,
} from "../../language/gen/index.js";
import { MuDForM_ModelWorker } from "./MuDForM_ModelWorker.js";
import { FreLogger, FreNode } from "@freon4dsl/core";

const LOGGER = new FreLogger("MuDForM_ModelWalker");

/**
 * Class MuDForM_ModelWalker implements the extended visitor pattern of instances of language MuDForM_Model.
 * This class implements the traversal of the model tree, classes that implement MuDForM_ModelWorker
 * are responsible for the actual work being done on the nodes of the tree.
 * Every node is visited twice, once before the visit of its children, and once after this visit.
 *
 * With the use of the parameter 'includeChildren', which takes a function, a very fine-grained control can be taken
 * over which nodes are and are not visited.
 */
export class MuDForM_ModelWalker {
    myWorkers: MuDForM_ModelWorker[] = []; // the instances that do the actual work on each node of the tree

    /**
     * This method is the entry point of the traversal through the model tree. Each of the workers will be called in
     * the order in which they are present in the array 'myWorkers'. If, for a tree node, a worker returns 'false',
     * none of the rest of the workers will be called. For that particular node both the 'execBefore' and 'execAfter'
     * method of any of the other workers will be skipped.
     *
     * @param modelelement the top node of the part of the tree to be visited
     * @param includeChildren if true, the children of 'modelelement' will also be visited
     */
    public walk(modelelement: FreNode, includeChildren?: (elem: FreNode) => boolean) {
        if (this.myWorkers.length > 0) {
            if (modelelement instanceof SimpleValueDef) {
                return this.walkSimpleValueDef(modelelement, includeChildren);
            }
            if (modelelement instanceof DbType) {
                return this.walkDbType(modelelement, includeChildren);
            }
            if (modelelement instanceof ReferenceAttribute) {
                return this.walkReferenceAttribute(modelelement, includeChildren);
            }
            if (modelelement instanceof ValueAttribute) {
                return this.walkValueAttribute(modelelement, includeChildren);
            }
            if (modelelement instanceof TransitionDef) {
                return this.walkTransitionDef(modelelement, includeChildren);
            }
            if (modelelement instanceof EntityDef) {
                return this.walkEntityDef(modelelement, includeChildren);
            }
            if (modelelement instanceof ValueDef) {
                return this.walkValueDef(modelelement, includeChildren);
            }
            if (modelelement instanceof ConceptDefinitions) {
                return this.walkConceptDefinitions(modelelement, includeChildren);
            }
            if (modelelement instanceof MuDForM_Model) {
                return this.walkMuDForM_Model(modelelement, includeChildren);
            }
        } else {
            LOGGER.error("No worker found.");
        }
    }

    private walkSimpleValueDef(modelelement: SimpleValueDef, includeChildren?: (elem: FreNode) => boolean) {
        let stopWalkingThisNode: boolean = false;
        for (const worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execBeforeSimpleValueDef(modelelement);
            }
        }

        for (let worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execAfterSimpleValueDef(modelelement);
            }
        }
    }

    private walkDbType(modelelement: DbType, includeChildren?: (elem: FreNode) => boolean) {
        let stopWalkingThisNode: boolean = false;
        for (const worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execBeforeDbType(modelelement);
            }
        }

        for (let worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execAfterDbType(modelelement);
            }
        }
    }

    private walkReferenceAttribute(modelelement: ReferenceAttribute, includeChildren?: (elem: FreNode) => boolean) {
        let stopWalkingThisNode: boolean = false;
        for (const worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execBeforeReferenceAttribute(modelelement);
            }
        }

        for (let worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execAfterReferenceAttribute(modelelement);
            }
        }
    }

    private walkValueAttribute(modelelement: ValueAttribute, includeChildren?: (elem: FreNode) => boolean) {
        let stopWalkingThisNode: boolean = false;
        for (const worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execBeforeValueAttribute(modelelement);
            }
        }

        for (let worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execAfterValueAttribute(modelelement);
            }
        }
    }

    private walkTransitionDef(modelelement: TransitionDef, includeChildren?: (elem: FreNode) => boolean) {
        let stopWalkingThisNode: boolean = false;
        for (const worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execBeforeTransitionDef(modelelement);
            }
        }
        // work on children in the model tree
        modelelement.parameters.forEach((p) => {
            if (!(includeChildren === undefined) && includeChildren(p)) {
                this.walk(p, includeChildren);
            }
        });
        modelelement.involvements.forEach((p) => {
            if (!(includeChildren === undefined) && includeChildren(p)) {
                this.walk(p, includeChildren);
            }
        });

        for (let worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execAfterTransitionDef(modelelement);
            }
        }
    }

    private walkEntityDef(modelelement: EntityDef, includeChildren?: (elem: FreNode) => boolean) {
        let stopWalkingThisNode: boolean = false;
        for (const worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execBeforeEntityDef(modelelement);
            }
        }
        // work on children in the model tree
        modelelement.properties.forEach((p) => {
            if (!(includeChildren === undefined) && includeChildren(p)) {
                this.walk(p, includeChildren);
            }
        });
        modelelement.relations.forEach((p) => {
            if (!(includeChildren === undefined) && includeChildren(p)) {
                this.walk(p, includeChildren);
            }
        });

        for (let worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execAfterEntityDef(modelelement);
            }
        }
    }

    private walkValueDef(modelelement: ValueDef, includeChildren?: (elem: FreNode) => boolean) {
        let stopWalkingThisNode: boolean = false;
        for (const worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execBeforeValueDef(modelelement);
            }
        }

        for (let worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execAfterValueDef(modelelement);
            }
        }
    }

    private walkConceptDefinitions(modelelement: ConceptDefinitions, includeChildren?: (elem: FreNode) => boolean) {
        let stopWalkingThisNode: boolean = false;
        for (const worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execBeforeConceptDefinitions(modelelement);
            }
        }
        // work on children in the model tree
        modelelement.simple_values.forEach((p) => {
            if (!(includeChildren === undefined) && includeChildren(p)) {
                this.walk(p, includeChildren);
            }
        });
        modelelement.entities.forEach((p) => {
            if (!(includeChildren === undefined) && includeChildren(p)) {
                this.walk(p, includeChildren);
            }
        });
        modelelement.transitions.forEach((p) => {
            if (!(includeChildren === undefined) && includeChildren(p)) {
                this.walk(p, includeChildren);
            }
        });

        for (let worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execAfterConceptDefinitions(modelelement);
            }
        }
    }

    private walkMuDForM_Model(modelelement: MuDForM_Model, includeChildren?: (elem: FreNode) => boolean) {
        let stopWalkingThisNode: boolean = false;
        for (const worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execBeforeMuDForM_Model(modelelement);
            }
        }
        // work on children in the model tree
        modelelement.units.forEach((p) => {
            if (!(includeChildren === undefined) && includeChildren(p)) {
                this.walk(p, includeChildren);
            }
        });

        for (let worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execAfterMuDForM_Model(modelelement);
            }
        }
    }
}
