// Generated by the Freon Language Generator.
// import { FreNode } from "../../language/gen/index.js";
import {
    ValueTypeReference,
    ListValueType,
    SumValueType,
    ProductValueType,
    SimpleValueType,
    ReferenceAttribute,
    ValueAttribute,
    TransitionTypeDef,
    EntityTypeDef,
    TypeField,
    DatomicType,
    ValueType,
    ValueTypeDef,
    ConceptTypeDefinitions,
    MuDForM_Model,
} from "../../language/gen/index.js";
import { MuDForM_ModelWorker } from "./MuDForM_ModelWorker.js";
import { FreLogger, FreNode } from "@freon4dsl/core";

const LOGGER = new FreLogger("MuDForM_ModelWalker");

/**
 * Class MuDForM_ModelWalker implements the extended visitor pattern of instances of language MuDForM_Model.
 * This class implements the traversal of the model tree, classes that implement MuDForM_ModelWorker
 * are responsible for the actual work being done on the nodes of the tree.
 * Every node is visited twice, once before the visit of its children, and once after this visit.
 *
 * With the use of the parameter 'includeChildren', which takes a function, a very fine-grained control can be taken
 * over which nodes are and are not visited.
 */
export class MuDForM_ModelWalker {
    myWorkers: MuDForM_ModelWorker[] = []; // the instances that do the actual work on each node of the tree

    /**
     * This method is the entry point of the traversal through the model tree. Each of the workers will be called in
     * the order in which they are present in the array 'myWorkers'. If, for a tree node, a worker returns 'false',
     * none of the rest of the workers will be called. For that particular node both the 'execBefore' and 'execAfter'
     * method of any of the other workers will be skipped.
     *
     * @param modelelement the top node of the part of the tree to be visited
     * @param includeChildren if true, the children of 'modelelement' will also be visited
     */
    public walk(modelelement: FreNode, includeChildren?: (elem: FreNode) => boolean) {
        if (this.myWorkers.length > 0) {
            if (modelelement instanceof ValueTypeReference) {
                return this.walkValueTypeReference(modelelement, includeChildren);
            }
            if (modelelement instanceof ListValueType) {
                return this.walkListValueType(modelelement, includeChildren);
            }
            if (modelelement instanceof SumValueType) {
                return this.walkSumValueType(modelelement, includeChildren);
            }
            if (modelelement instanceof ProductValueType) {
                return this.walkProductValueType(modelelement, includeChildren);
            }
            if (modelelement instanceof SimpleValueType) {
                return this.walkSimpleValueType(modelelement, includeChildren);
            }
            if (modelelement instanceof ReferenceAttribute) {
                return this.walkReferenceAttribute(modelelement, includeChildren);
            }
            if (modelelement instanceof ValueAttribute) {
                return this.walkValueAttribute(modelelement, includeChildren);
            }
            if (modelelement instanceof TransitionTypeDef) {
                return this.walkTransitionTypeDef(modelelement, includeChildren);
            }
            if (modelelement instanceof EntityTypeDef) {
                return this.walkEntityTypeDef(modelelement, includeChildren);
            }
            if (modelelement instanceof TypeField) {
                return this.walkTypeField(modelelement, includeChildren);
            }
            if (modelelement instanceof DatomicType) {
                return this.walkDatomicType(modelelement, includeChildren);
            }
            if (modelelement instanceof ValueType) {
                return this.walkValueType(modelelement, includeChildren);
            }
            if (modelelement instanceof ValueTypeDef) {
                return this.walkValueTypeDef(modelelement, includeChildren);
            }
            if (modelelement instanceof ConceptTypeDefinitions) {
                return this.walkConceptTypeDefinitions(modelelement, includeChildren);
            }
            if (modelelement instanceof MuDForM_Model) {
                return this.walkMuDForM_Model(modelelement, includeChildren);
            }
        } else {
            LOGGER.error("No worker found.");
        }
    }

    private walkValueTypeReference(modelelement: ValueTypeReference, includeChildren?: (elem: FreNode) => boolean) {
        let stopWalkingThisNode: boolean = false;
        for (const worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execBeforeValueTypeReference(modelelement);
            }
        }

        for (let worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execAfterValueTypeReference(modelelement);
            }
        }
    }

    private walkListValueType(modelelement: ListValueType, includeChildren?: (elem: FreNode) => boolean) {
        let stopWalkingThisNode: boolean = false;
        for (const worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execBeforeListValueType(modelelement);
            }
        }
        // work on children in the model tree
        if (!(includeChildren === undefined) && includeChildren(modelelement.list)) {
            this.walk(modelelement.list, includeChildren);
        }

        for (let worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execAfterListValueType(modelelement);
            }
        }
    }

    private walkSumValueType(modelelement: SumValueType, includeChildren?: (elem: FreNode) => boolean) {
        let stopWalkingThisNode: boolean = false;
        for (const worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execBeforeSumValueType(modelelement);
            }
        }
        // work on children in the model tree
        modelelement.fields.forEach((p) => {
            if (!(includeChildren === undefined) && includeChildren(p)) {
                this.walk(p, includeChildren);
            }
        });

        for (let worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execAfterSumValueType(modelelement);
            }
        }
    }

    private walkProductValueType(modelelement: ProductValueType, includeChildren?: (elem: FreNode) => boolean) {
        let stopWalkingThisNode: boolean = false;
        for (const worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execBeforeProductValueType(modelelement);
            }
        }
        // work on children in the model tree
        modelelement.fields.forEach((p) => {
            if (!(includeChildren === undefined) && includeChildren(p)) {
                this.walk(p, includeChildren);
            }
        });

        for (let worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execAfterProductValueType(modelelement);
            }
        }
    }

    private walkSimpleValueType(modelelement: SimpleValueType, includeChildren?: (elem: FreNode) => boolean) {
        let stopWalkingThisNode: boolean = false;
        for (const worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execBeforeSimpleValueType(modelelement);
            }
        }

        for (let worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execAfterSimpleValueType(modelelement);
            }
        }
    }

    private walkReferenceAttribute(modelelement: ReferenceAttribute, includeChildren?: (elem: FreNode) => boolean) {
        let stopWalkingThisNode: boolean = false;
        for (const worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execBeforeReferenceAttribute(modelelement);
            }
        }

        for (let worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execAfterReferenceAttribute(modelelement);
            }
        }
    }

    private walkValueAttribute(modelelement: ValueAttribute, includeChildren?: (elem: FreNode) => boolean) {
        let stopWalkingThisNode: boolean = false;
        for (const worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execBeforeValueAttribute(modelelement);
            }
        }

        for (let worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execAfterValueAttribute(modelelement);
            }
        }
    }

    private walkTransitionTypeDef(modelelement: TransitionTypeDef, includeChildren?: (elem: FreNode) => boolean) {
        let stopWalkingThisNode: boolean = false;
        for (const worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execBeforeTransitionTypeDef(modelelement);
            }
        }
        // work on children in the model tree
        modelelement.parameters.forEach((p) => {
            if (!(includeChildren === undefined) && includeChildren(p)) {
                this.walk(p, includeChildren);
            }
        });
        modelelement.involvements.forEach((p) => {
            if (!(includeChildren === undefined) && includeChildren(p)) {
                this.walk(p, includeChildren);
            }
        });

        for (let worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execAfterTransitionTypeDef(modelelement);
            }
        }
    }

    private walkEntityTypeDef(modelelement: EntityTypeDef, includeChildren?: (elem: FreNode) => boolean) {
        let stopWalkingThisNode: boolean = false;
        for (const worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execBeforeEntityTypeDef(modelelement);
            }
        }
        // work on children in the model tree
        modelelement.properties.forEach((p) => {
            if (!(includeChildren === undefined) && includeChildren(p)) {
                this.walk(p, includeChildren);
            }
        });
        modelelement.relations.forEach((p) => {
            if (!(includeChildren === undefined) && includeChildren(p)) {
                this.walk(p, includeChildren);
            }
        });

        for (let worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execAfterEntityTypeDef(modelelement);
            }
        }
    }

    private walkTypeField(modelelement: TypeField, includeChildren?: (elem: FreNode) => boolean) {
        let stopWalkingThisNode: boolean = false;
        for (const worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execBeforeTypeField(modelelement);
            }
        }
        // work on children in the model tree
        if (!(includeChildren === undefined) && includeChildren(modelelement.type)) {
            this.walk(modelelement.type, includeChildren);
        }

        for (let worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execAfterTypeField(modelelement);
            }
        }
    }

    private walkDatomicType(modelelement: DatomicType, includeChildren?: (elem: FreNode) => boolean) {
        let stopWalkingThisNode: boolean = false;
        for (const worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execBeforeDatomicType(modelelement);
            }
        }

        for (let worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execAfterDatomicType(modelelement);
            }
        }
    }

    private walkValueType(modelelement: ValueType, includeChildren?: (elem: FreNode) => boolean) {
        let stopWalkingThisNode: boolean = false;
        for (const worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execBeforeValueType(modelelement);
            }
        }

        for (let worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execAfterValueType(modelelement);
            }
        }
    }

    private walkValueTypeDef(modelelement: ValueTypeDef, includeChildren?: (elem: FreNode) => boolean) {
        let stopWalkingThisNode: boolean = false;
        for (const worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execBeforeValueTypeDef(modelelement);
            }
        }
        // work on children in the model tree
        if (!(includeChildren === undefined) && includeChildren(modelelement.type)) {
            this.walk(modelelement.type, includeChildren);
        }

        for (let worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execAfterValueTypeDef(modelelement);
            }
        }
    }

    private walkConceptTypeDefinitions(modelelement: ConceptTypeDefinitions, includeChildren?: (elem: FreNode) => boolean) {
        let stopWalkingThisNode: boolean = false;
        for (const worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execBeforeConceptTypeDefinitions(modelelement);
            }
        }
        // work on children in the model tree
        modelelement.values.forEach((p) => {
            if (!(includeChildren === undefined) && includeChildren(p)) {
                this.walk(p, includeChildren);
            }
        });
        modelelement.entities.forEach((p) => {
            if (!(includeChildren === undefined) && includeChildren(p)) {
                this.walk(p, includeChildren);
            }
        });
        modelelement.transitions.forEach((p) => {
            if (!(includeChildren === undefined) && includeChildren(p)) {
                this.walk(p, includeChildren);
            }
        });

        for (let worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execAfterConceptTypeDefinitions(modelelement);
            }
        }
    }

    private walkMuDForM_Model(modelelement: MuDForM_Model, includeChildren?: (elem: FreNode) => boolean) {
        let stopWalkingThisNode: boolean = false;
        for (const worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execBeforeMuDForM_Model(modelelement);
            }
        }
        // work on children in the model tree
        modelelement.units.forEach((p) => {
            if (!(includeChildren === undefined) && includeChildren(p)) {
                this.walk(p, includeChildren);
            }
        });

        for (let worker of this.myWorkers) {
            if (!stopWalkingThisNode) {
                stopWalkingThisNode = worker.execAfterMuDForM_Model(modelelement);
            }
        }
    }
}
